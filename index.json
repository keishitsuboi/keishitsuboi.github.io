[{"categories":[],"content":"こんにちは、技術部の手島です。 弊社では、脆弱性診断サービスの１つとして組み込み機器診断を行っていますが、その作業の一つとして記憶媒体からファームウェアを読み出す作業があります。この目的で弊社ではデータ復旧装置を保有しており、技能維持トレーニングを行っている様子を紹介します。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:0:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"今回はなにするの？ データ復旧の技能維持トレーニングとして、NANDフラッシュメモリを使用した記憶媒体を破棄する際に、データ消去が不適切な場合には残ったデータがどう見えるのか、実際にUSBメモリを用いて検証してみます。 このようにNANDコントローラが破損・破壊されたという前提で、USBメモリをデータ復旧させます。この状態で生存しているのは裏側のNANDフラッシュメモリのみです。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:1:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"準備 実験台として、秋葉原で8GBの容量のUSBメモリをいくつか購入しました。今回は、予め内容が分かっているファイルをUSBメモリに保存し、Windows OSのフォーマット機能である「クイックフォーマット」と「(通常の)フォーマット」を行い、 ファイルシステム上のファイル有無 フラッシュメモリ上の残存 データ復旧の可否 を検証していきます。 なお、今回は私のデータ復旧トレーニングを兼ねているため、あえてddコマンド等ではなく、NANDコントローラが破損しているという前提で読み出しとデータ復旧をしています。 こちらが書き込んだファイル類と書き込み先のフォルダです。USBメモリには、MP3形式の音楽ファイル、PDFファイル、Microsoft Office系のWord、Excel用のファイル、JPG形式の画像ファイルを各5つ程度保存しました。フォルダ名もあえて分かりやすく番号を振って命名しています。 各ファイルは、音楽ファイルは甘茶の音楽工房様、PDF、Excelファイルは経済産業省の資源・エネルギー統計、Wordファイルは警視庁の車庫証明申請書等を利用させていただきました。お礼を申し上げます。 甘茶の音楽工房 https://amachamusic.chagasi.com/ 資源・エネルギー統計等 経済産業省 https://www.enecho.meti.go.jp/statistics/petroleum_and_lpgas/oil_general/ 保管場所証明申請手続　警視庁 https://www.keishicho.metro.tokyo.lg.jp/tetsuzuki/kotsu/hokan/syako_tetsuzuki/jidousha_syomei.html ファイルを保存したので、1つ目のUSBメモリをクイックフォーマットします。クイックフォーマットは2秒足らずで終わります。これでひとまず準備は終わりました。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:2:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"1:クイックフォーマットしたUSBメモリのデータ復旧 早速USBメモリを解体して基板のみを取り出し、搭載されているICの役割を写真に記載しました。この基板は、NANDフラッシュメモリを2個搭載することができるようです。これは私の憶測ですが、NANDフラッシュメモリ1枚のみ搭載した低価格品から大容量のハイエンド品まで対応できることを狙った設計でしょうか。 NANDコントローラはPHISON社のPS2251-07、NANDフラッシュメモリは刻印からはメーカーと型番が分かりませんでした。NANDフラッシュメモリには固有のIDを返答する仕組みが備わっているため、データ復旧装置から「お前誰やねん」と聞くと、「ワシは ○○社製の ▲▲やで」と教えてくれますので、NANDフラッシュメモリはメーカーが分からなくても問題ありません。 試しに読み取り装置にかけてみると、このNANDフラッシュメモリは東芝製の TC58TEG6DDJTA00 とのことです。パッケージに刻印が無いため、NANDフラッシュメモリが返答してきた型番（デバイスID）が本当に正しいのかは不明です。型番と合致しているか判定するためには、パッケージをレーザーなどで開封し、ダイを露出させ、信頼できる仕入元から入手した正規品と比較しなければ分かりません。パッケージ表面に東芝メモリの刻印が無い理由も不明です。このNANDフラッシュメモリはどのような流通経路を辿ってきたのでしょうね。 不思議なNANDフラッシュメモリは今回の本質ではないので、気にせずデータ復旧に取り掛かりましょう。 NANDフラッシュメモリ内のデータをイメージとして俯瞰して見ると、一部に何かが残っているように見えますが、ファイルヘッダ等には見えません。調査をしてみると、このNANDコントローラはデータを特定のパターンでXORしながら、複数のブロックの、複数のページへ、並列に書き込むことが分かり、段々とファイルの一部が復元できるようになってきました。 途中のデータ内から「Microsoft Office Word」の文字が見えました。データ復旧装置での作業は省略しますが、このように少しずつ手順を踏んでファイルを復元していきます。この後、NANDコントローラがNANDフラッシュメモリにどう書き込むのか判明したため、復旧が完了しました。ファイルシステムを復元します。 ファイルシステム上ではファイルが残っていないように見え、これはクイックフォーマットによるものです。本当にデータは消えているのでしょうか。ファイルシステムのFATに頼らず、フラッシュメモリ全体を調査したのが以下の画面です。 ファイルが残存していることが分かります。クイックフォーマットでは、FATテーブルが削除されただけです。NANDフラッシュメモリ全体からデータが残っていないか探すと、先ほど保存したデータが全て復元できました。 厚い本に例えると、本文であるファイルをどこに書いたのか記録した「目次」がFATテーブルであり、クイックフォーマットは目次を白紙にしただけです。ファイルが消えているように見えるのは目次が白紙になっているためで、本をめくり続けると本文が読める、というような感覚です。記憶媒体を廃棄する際、クイックフォーマットだけだとデータ消去としては不適切なのが分かりますね。 1:クイックフォーマットしたUSBメモリのまとめ ファイルシステム上のファイル有無：無し フラッシュメモリ上の残存：あり データ復旧の可否：可能 FATテーブルが削除されただけであり、フラッシュメモリ上にデータは残っている。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:3:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"2: 通常のフォーマットをしたUSBメモリ　データ復旧 では、クイックフォーマットではない通常のフォーマットではどうでしょうか。Windowsが行う通常のフォーマットは、全て 0 を書き込むそうです。 先ほどと同様にファイルをUSBメモリに保存し、「クイックフォーマット」のチェックを外してフォーマットします。完了するまで約4分半かかりました。先ほどと同様にNANDフラッシュメモリを取り外し、中身を確認していきます。 同じようにデータ復旧しますが、何のファイルも見つかりません。あるのはマスターブートレコードのみです。 イメージにして俯瞰しても先ほどと違って真っ白です。データは何も残っておらず、ずっと 0 が書き込まれています。クイックではない通常のフォーマットでは、目次のFATテーブルも本文も全て白紙にしていることが分かりました。 2:通常のフォーマットをしたUSBメモリのまとめ ファイルシステム上のファイル有無：無し フラッシュメモリ上の残存：無し データ復旧の可否：不可能 FATテーブル、MBR、バッドブロックを除いたフラッシュメモリ全体に渡って0が書き込まれており、データは残っていない。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:4:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"まとめ 今回の検証で、読んでいただいた方に「クイックフォーマットではデータは残る」ということが伝わればうれしいです。記憶媒体を廃棄する際は、データの消去方式にはいくつか方法がありますが、少なくともクイックフォーマットではない「通常のフォーマット」はある程度の効果がありそうです。（本表現は効果の保証をするものではありません。適切な処理が求められる場合にはデータ消去の専門業者さんへご依頼下さい。）また、USBメモリ内のNANDフラッシュメモリを物理破壊することも効果的です。弊社の社内規定では、記憶媒体を廃棄する際にはデータの論理削除後に物理破壊することが必須と規定されています。 ICの物理破壊時も、どのICを破壊してもよいわけではなく、適切なICを確実に破壊しなければいけません。今回は下の写真のようにNANDコントローラが破壊された前提で行いましたが、これではデータ復旧が可能でしたね。 データはこちらのNANDフラッシュメモリに保存されているので、NANDコントローラではなくこちらを確実に破壊しなければいけません。 今回搭載されていたNANDフラッシュメモリはTSOP48という形状のものですが、他にもNANDフラッシュメモリには、ICのピンが出ていない表面実装品のBGA63等、いくつか形状違いのものがあります。 BGA63パッケージの例、写真はDigikey.comより https://www.digikey.com/en/products/detail/kioxia-america-inc/TH58NYG2S3HBAI4/8638959 また、クイックフォーマットは使用するべきではないかというとそうではありません。NANDフラッシュメモリには書き込みできる回数の寿命があるため、不必要な書き込みを行わないクイックフォーマットには大きな利点があります。（私も普段使用しているUSBメモリ等はクイックフォーマットです。） 最後まで読んでいただきありがとうございました。 ","date":"2021-12-03","objectID":"/%E7%A0%B4%E5%A3%8A/:5:0","tags":["Embedded","IoT"],"title":"破壊・フォーマットされたUSBメモリからデータを復旧する","uri":"/%E7%A0%B4%E5%A3%8A/"},{"categories":[],"content":"ファイルベースの暗号化の説明にある通り、Android7.0以降ではファイルベースの暗号化（FBE）がサポートされています。Android10の/data/data/領域（最初のユーザーのアプリストレージ）もFBEで暗号化されています。FBEによる暗号化はスクリーンロック設定の有無に関わらず行われていますが、スクリーンロック設定が無い方が復号に必要な情報が少なくなります。 スクリーンロック設定が無いAndroid10のエミュレータから/data/data/に該当する領域をダンプし、PC（Linux）で復号を試みたところ成功しました。本稿では使用した環境とその手順について記載します。 ","date":"2021-08-03","objectID":"/android10/:0:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"1.手順の概要 大きく分けて３つの手順を踏みます。 Android10のエミュレータから、復号対象のデータをダンプ Android10のエミュレータから、復号用の鍵をダンプ ダンプしたデータと鍵を使用して、PCで復号 2.の手順については、以下の２つの方法があります。詳細については後述します。 Androidのソースコードをダウンロードし、その中のvoldのソースコードの一部を改変した上でビルドして実行する方法 Fridaを使う方法 ","date":"2021-08-03","objectID":"/android10/:1:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"2.使用した環境 ","date":"2021-08-03","objectID":"/android10/:2:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"2.1 PC Arch Linux (5.10.50-1-lts) ","date":"2021-08-03","objectID":"/android10/:2:1","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"2.2 Androidのエミュレータ Android StudioのAVD Managerから作成しました。 Release Name: Q API Level: 29 ABI: x86_64 Target: Android10.0(Google APIs) Hardware: root権限が取得可能なもの（＝Play Storeにチェックが入っていないもの） スクリーンロック設定: 無し ","date":"2021-08-03","objectID":"/android10/:2:2","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ビルド環境 DockerのUbuntu 18.04 ","date":"2021-08-03","objectID":"/android10/:2:3","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"コマンドの実行例の表記について 本稿ではいくつかコマンドの実行例を記載します。 複数の環境での実行例を記載するため、実行環境の区別を以下の表記で行います。 先頭部分の表記 意味 $ PC上での実行 generic_x86_64:/ # Android10のエミュレータ上でのroot権限での実行 root@263eeed4469e: DockerのUbuntu18.04での実行 ","date":"2021-08-03","objectID":"/android10/:3:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"手順1. Android10のエミュレータから、復号対象のデータをダンプ ","date":"2021-08-03","objectID":"/android10/:4:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"FBEで暗号化されているか確認 ro.crypto.stateとro.crypto.typeの内容をチェックします。 generic_x86_64:/ # getprop | grep crypto [ro.crypto.state]: [encrypted] [ro.crypto.type]: [file] [ro.crypto.volume.filenames_mode]: [aes-256-cts] ","date":"2021-08-03","objectID":"/android10/:4:1","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ダンプ対象の確認 generic_x86_64:/ # mount | grep ' /data ' /dev/block/vdc on /data type ext4 (rw,seclabel,nosuid,nodev,noatime,resgid=1065,errors=panic,data=ordered) /dev/block/vdcをダンプすることになります。 ","date":"2021-08-03","objectID":"/android10/:4:2","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"データのダンプ PCの受け側 $ nc -l -p 9999 | gzip -d \u003e ret Android側 generic_x86_64:/ # dd if=/dev/block/vdc | gzip | nc 10.0.2.2 9999 10.0.2.2はPCのIPです。 ","date":"2021-08-03","objectID":"/android10/:4:3","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ダンプしたデータの確認 成功するとretというファイル名のファイルがPC側にできます。サイズは800MBでした。 $ file ret ret: Linux rev 1.0 ext4 filesystem data, UUID=57f8f4bc-ffffabf4-655f-ffffbf67-946fc0f9fffff25b (needs journal recovery) (extents) (large files) ","date":"2021-08-03","objectID":"/android10/:4:4","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ダンプしたデータのマウント FBEはファイル単位の暗号化のためか、復号用の鍵を知らなくてもマウントすることができました。 $ mkdir tmp $ sudo mount -oloop,ro ret tmp $ ls tmp/ adb app-asec app-staging dalvik-cache local mediadrm nfc property server_configurable_flags system_de user_de anr app-ephemeral backup data local.prop misc ota resource-cache ss tombstones vendor apex app-lib bootchart drm lost+found misc_ce ota_package rollback system unencrypted vendor_ce app app-private cache gsi media misc_de preloads rollback-observer system_ce user vendor_de /data/直下はFBEによる暗号化は行われていないようです。 そして、/data/data/に相当する箇所を確認すると、暗号化されていることがわかります。 $ ls tmp/data/ AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFv+,EJZbQdnYQu,rXx6wTNt6JEB5BEUVfoPVzahC AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFv+65J8t6x7+3YXOzBqRWJk0nZdM39n2JkYkNodB AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFv+oKatth8Nj8ikU7+6YN1+2nZdM39n2JkYkNodB AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFvAYNJohexPAXaBEWJ75Flh8,LLjzQ,UyFg9JQr0o7KvB AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFvJPVfmuqrowGnKw9GraApO0nZdM39n2JkYkNodB AAAAAAAAAAA,2zZ+TpRQYRLlS6VnXUFvUNayNrjrDFXzDkoOrxMUF+,LLjzQ,UyFg9JQr0o7KvB （以下省略） ","date":"2021-08-03","objectID":"/android10/:4:5","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"手順2. Android10のエミュレータから、復号用の鍵をダンプ 次に、復号用の鍵をAndroid10のエミュレータから取得します。ここでは、Androidのソースコードをダウンロードし、その中のvoldのコードの一部を改変した上でビルドして実行する方法について記述します。Fridaを使う方法については後述します。 ファイルベースの暗号化: 鍵の派生の中に、以下のような記述があります。 512 ビットの鍵であるファイルベースの暗号鍵は、TEE に保持された別の鍵（256 ビット AES-GCM 鍵）で暗号化されてから保存されます。 TEEとはTrusted Execution Environmentのことです。TEEについての説明は割愛しますが、要するに復号用の鍵が単体のファイルとして存在するわけではないということです。 復号用の鍵を手軽に取得する方法はないかと探していたところ、ファイルベースの暗号化: 例とソースに、以下のような記述がありました。 Android にはファイルベースの暗号化のリファレンス実装が用意されており、vold（system/vold）によって Android のストレージ デバイスとボリュームを管理する機能が提供されます。FBE を追加すると、複数のユーザーの CE 鍵と DE 鍵の管理に対応したいくつかの新しいコマンドが vold に提供されます。 CE鍵とDE鍵については、ファイルベースの暗号化: ダイレクト ブートを参照してください。/data/data/領域の復号に必要なのはCE鍵です。上記の記述によると、voldのコードを参照すると復号用の鍵の取得方法が分かりそうです。 そこでvoldのコードを調べたところ、鍵を取得する関数が見つかりました。 // Retrieve the key from the named directory. bool retrieveKey(const std::string\u0026 dir, const KeyAuthentication\u0026 auth, KeyBuffer* key, bool keepOld = false); 第１引数には、鍵に関連するファイルが置いてあるディレクトリを指定します。今回の目的では、/data/misc/vold/user_keys/ce/0/currentを指定することになります。 第２引数には、鍵の派生で説明されている情報に関連するデータを渡します。しかし、スクリーンロック設定が無い場合はkEmptyAuthenticationを指定するだけで良いのでお手軽です。 第３引数は、この関数の実行結果を格納するバッファです。このデータが今回求めている復号用の鍵そのものです。 関数retrieveKey()を呼び出せば、/data/data/の復号用の鍵を取得できることが分かりました。そこで、Androidのソースコードをダウンロードして、voldのコードをretrieveKey()を呼び出してその結果を保存するように書き換えた上でビルドすることにしました。それをAndroid10のエミュレータ上で実行すれば、復号用の鍵を取得できます。 ","date":"2021-08-03","objectID":"/android10/:5:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ソースコードのダウンロード 詳細はソースのダウンロードを参照してください。 $ mkdir tmp $ cd tmp $ repo init --depth=1 -u https://android.googlesource.com/platform/manifest -b android-10.0.0_r45 $ repo sync ","date":"2021-08-03","objectID":"/android10/:5:1","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"voldのソースコードの改変 ダウンロードしたソースコードの system/vold/main.cpp を以下の様に改変します。 #include \u003candroid-base/file.h\u003e #include \"KeyStorage.h\" int main(int argc, char** argv) { if(argc != 3) return -1; android::vold::KeyBuffer key; android::vold::retrieveKey(argv[1], android::vold::kEmptyAuthentication, \u0026key); android::base::WriteStringToFile(std::string(key.data(), key.size()), argv[2], false); } retrieveKey()を実行して、結果（つまり復号用の鍵）をargv[2]で渡されたファイル名で保存して終了するプログラムです。retrieveKey()は実行の成否をbool値で返してくれるようですが、今回は気にしないことにしています。 ","date":"2021-08-03","objectID":"/android10/:5:2","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"ビルド 改変したvoldをビルドします。公式ページによると、ビルド環境としてUbuntuのバージョンがいくつか挙げられています。今回はDockerのUbuntu 18.04で作業することにしました。本稿ではDockerの導入や使用方法については割愛します。また、ダウンロードしたソースコードもDocker内から参照できるようにmountしておきます。本稿では/mnt/で参照できるようにしています。 まずはDockerを起動します。 $ sudo docker run -it -v ダウンロードしたソースコードの絶対パス:/mnt/ ubuntu:18.04 次に、必要なパッケージをインストールします。 root@263eeed4469e:~# apt update root@263eeed4469e:~# apt-get install -y git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig python そして、ビルドします。 root@263eeed4469e:~# cd /mnt/ root@263eeed4469e:/mnt# export LC_ALL=C root@263eeed4469e:/mnt# source build/envsetup.sh root@263eeed4469e:/mnt# lunch aosp_x86_64-eng root@263eeed4469e:/mnt# cd system/vold/ root@263eeed4469e:/mnt/system/vold# mma 手元の環境では、15分程度で完了しました。/mnt/out/target/product/generic_x86_64/system/bin/vold が求めるファイルです。このファイルをAndroid10のエミュレータにコピーします。本物のvoldと混同しない様にファイル名も変更しておきます。 $ adb push out/target/product/generic_x86_64/system/bin/vold /data/local/tmp/dump ","date":"2021-08-03","objectID":"/android10/:5:3","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"実行 generic_x86_64:/ # cd /data/local/tmp generic_x86_64:/data/local/tmp # chmod +x dump generic_x86_64:/data/local/tmp # ./dump /data/misc/vold/user_keys/ce/0/current ce_key generic_x86_64:/data/local/tmp # xxd -g 1 ce_key 00000000: 63 47 c7 01 04 00 27 c4 d5 8f 2b 1b a8 94 9c ed cG....'...+..... 00000010: a9 65 92 44 fe 25 ea 91 93 25 97 05 e1 41 48 1e .e.D.%...%...AH. 00000020: ed 52 3c fe 67 83 d5 ca c1 40 fe f3 f3 f1 98 10 .R\u003c.g....@...... 00000030: 88 64 46 16 95 69 59 d5 b2 19 ce 72 fc 48 a1 6a .dF..iY....r.H.j 復号用の鍵が取得できました。ランダムに生成されているようなので、値は環境ごとに異なります。 ","date":"2021-08-03","objectID":"/android10/:5:4","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"手順3. ダンプしたデータと鍵を使用して、PCで復号 手順1でマウントはしているので、鍵を登録すれば読めるようになります。 ファイルベースの暗号化: fscrypt暗号化の項目に記載されている通り、fscryptによって暗号化されています。そこで、fscryptctlを使って鍵の登録を行います。 本稿ではAndroid10のエミュレータを対象としていますが、ファイルベースの暗号化: 内部ストレージの項目に記載されている通り、Android10では暗号化ポリシーとしてv1が使用されています。 v1 フラグを指定するとバージョン 1 の暗号化ポリシーが、v2 フラグを指定するとバージョン 2 の暗号化ポリシーが選択されます。バージョン 2 の暗号化ポリシーでは、安全性と柔軟性に優れた鍵導出関数が使用されます。デフォルトは、Android 11 以降を搭載して出荷されたデバイス（ro.product.first_api_level によって特定される）の場合は v2、Android 10 以前を搭載して出荷されたデバイスの場合は v1 です。 そして、fscryptctlでは2021/2/3のコミットでv1のサポートが落とされたため、その１つ前のコミットを使用することにします。 $ git clone https://github.com/google/fscryptctl/ $ cd fscryptctl/ $ git checkout 60812534fc3ecf3a43b67bfeee5c5a1bc7daadc8 $ make そして、鍵を読み込ませます。 $ adb pull /data/local/tmp/ce_key $ ./fscryptctl insert_key --ext4 \u003c ce_key ここで/data/data/に相当する箇所を確認すると、復号できていることが確認できます。成功しました。 $ ls tmp/data/ android com.android.theme.color.orchid com.android.apps.tag com.android.theme.color.purple com.android.backupconfirm com.android.theme.color.space com.android.bips com.android.theme.font.notoserifsource com.android.bluetooth com.android.theme.icon.roundedrect （以下省略） ","date":"2021-08-03","objectID":"/android10/:6:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"手順2-2. Fridaを使用して、復号用の鍵をダンプ 以上の手順で、voldのretrieveKey()を呼べば復号用の鍵が取得できることが分かりました。本物のvoldはAndroidの中で動いているため、Fridaを使用して本物のvoldの中でretrieveKey()を呼んでも復号用の鍵が取得できるのではないかと考えました。試してみたところ、取得に成功したのでその手順を記載します。Fridaの説明や使い方についてはFridaのサイトを参照してください。 本物のvold内のretrieveKey()を呼び出すために、retrieveKey()のアドレスを特定する必要があります。特定するために、Android10のエミュレータから本物のvoldを取得します。 $ adb root $ adb pull /system/bin/vold $ sha1sum vold d638e304a741ed6fbb1fa36a989d953208a73bfa vold 取得したvoldを解析すれば、retrieveKey()のアドレスを取得することができます。解析方法については割愛します。関数内で参照しているVersion mismatch, expectedという文字列で探せばすぐに見つかります。本稿で取得したvoldでは0x0004c230でした。 retrieveKey()は引数にC++の型が出てくるため、Fridaで実行する場合はここも工夫が必要です。 // Retrieve the key from the named directory. bool retrieveKey(const std::string\u0026 dir, const KeyAuthentication\u0026 auth, KeyBuffer* key, bool keepOld = false); 以下の方針で試したところ、うまくいきました。 第１引数のstd::stringは、std::string StringPrintf(const char* fmt, …)を使用して生成する。 第２引数はkEmptyAuthenticationを指定するので、本物のvoldからkEmptyAuthenticationのアドレスを探して使用する。voldの元々のコード上にもkEmptyAuthenticationを指定してretrieveKey()を呼び出している箇所があるので、retrieveKey()のアドレスが分かっていれば探すのは難しくありません。本稿で取得したvoldでは0x000e8178でした。 第３引数のKeyBufferはcharのvectorですが、ある程度のサイズの0初期化されたメモリを渡してやったところ、うまく動いた（メモリの先頭８バイトの部分に、復号用の鍵の先頭アドレスが入っていた）のでヨシ！としました。 最終的に以下のようなプログラムになりました。 let offset_kEmptyAuthentication = 0x000e8178; let offset_retrieveKey = 0x0004c230; let find = Module.findExportByName('libbase.so', '_ZN7android4base12StringPrintfEPKcz'); let android_base_StringPrintf = new NativeFunction(find, 'pointer', ['pointer', 'pointer']); let format = Memory.allocUtf8String('%s'); let dir = android_base_StringPrintf(format, Memory.allocUtf8String('/data/misc/vold/user_keys/ce/0/current')); let vold = Process.findModuleByName('vold'); let kEmptyAuthentication = (vold.base.add(offset_kEmptyAuthentication)); let keyBuffer = Memory.alloc(1024); let retrieveKey = new NativeFunction(vold.base.add(offset_retrieveKey), 'bool', ['pointer', 'pointer', 'pointer', 'bool']); retrieveKey(dir, kEmptyAuthentication, keyBuffer, 0); let key_addr = keyBuffer.readU64(); let key = (ptr(key_addr)).readByteArray(64); console.log('key:'); console.log(key); このプログラムをmain.jsというファイル名で保存して、Fridaで実行します。 まずvoldのPIDを取得します $ frida-ps -U | grep vold 1747 vold 取得したPIDに対してmain.jsを実行します。 $ frida -U -l main.js -p 1747 （中略） key: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF 00000000 63 47 c7 01 04 00 27 c4 d5 8f 2b 1b a8 94 9c ed cG....'...+..... 00000010 a9 65 92 44 fe 25 ea 91 93 25 97 05 e1 41 48 1e .e.D.%...%...AH. 00000020 ed 52 3c fe 67 83 d5 ca c1 40 fe f3 f3 f1 98 10 .R\u003c.g....@...... 00000030 88 64 46 16 95 69 59 d5 b2 19 ce 72 fc 48 a1 6a .dF..iY....r.H.j 手順2で取得した復号用の鍵と一致していることが分かります。 ","date":"2021-08-03","objectID":"/android10/:7:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"今後の課題 実機での実行について 本稿ではAndroid10のエミュレータで実行しましたが、復号用の鍵が取得できれば実機でも同様に復号できるのではないかと考えています。しかし、実機でも復号用の鍵の取得が本稿の方法で取得できるかどうかは、実際に検証する必要があるだろうと考えています。 スクリーンロック設定がある場合について スクリーンロック設定がある場合はretrieveKey()の第２引数にファイルベースの暗号化: 鍵の派生で記載されている情報を詰めてやる必要があるようです。特に１つ目の要件の認証トークンは、voldのコードを軽く読んだ感じでは他のプログラムからvoldに対して渡される情報のようなので、どのプログラムが渡しているのかを調査する必要がありそうです。この検証も、実機を使って検証する必要があるだろうと考えています。 Android11以降での実行について ファイルベースの暗号化: 内部ストレージに説明がある通り、FBEに関してAndroid11から導入された仕組みが存在し、本稿の実行環境であるAndroid10と違いがあるように見えます。Android11以降での復号についても、今後の課題としたいと思います。 ","date":"2021-08-03","objectID":"/android10/:8:0","tags":["Android"],"title":"ファイルベースの暗号化（FBE）されたAndroid10のエミュレータの/data/data/領域をPCで復号してみる","uri":"/android10/"},{"categories":[],"content":"Discover what the Hugo - LoveIt theme is all about and the core-concepts behind it.","date":"2020-10-26","objectID":"/bitlocker/","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"Windows の BitLocker、Linux ユーザーにはとてもうらやましいですよね。 Trusted Platform Module（TPM）が搭載された PC なら手軽にディスクを暗号化できて、パスフレーズ入力無しで OS 起動できて。 そんな Windows のうらやま機能を Kali Linux でやっていきます。 ","date":"2020-10-26","objectID":"/bitlocker/:0:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"1 はじめに 技術部の松永です。 2年ほど前にネットワークペネトレーションテストチームへ拉致られて以来、Linux で Windows をやっつけるツールの開発などやっています（楽しい）。 そんな縁もあり、ペネトレーションテストに使用する Linux PC を BitLocker のようにディスク暗号化しつつ自動起動できるようにする必要性が生じ、勉強する機会を得られました。 手順や得られた知識をブログで公開していきたいと思いますが、とりあえずやってみるだけでも 1 日作業になるため今回は手順のみ紹介したいと思います。 やれる環境のある方は是非チャレンジして頂き、やれる環境の無い方は次回以降で手順を解説するのでそちらを見てフムフムして頂けると幸いです。 本稿では Kali Linux を使いますが、Debian 系の他のディストリビューションでも同様の手順で実施できると考えています。 私は Kali Linux の他に Ubuntu（Focal Fossa） も試していますが、複雑な手順が必要だったのが Kali Linux です。 Kali Linux でできるなら他の Debian 系も大丈夫だろうと思いつつ、次回以降でディストリビューションの差異の話もしたいと思います。 ","date":"2020-10-26","objectID":"/bitlocker/:1:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"できるようになること Kali Linux を LUKS（Linux Unified Key Setup）でディスク暗号化してインストール Kali Linux のセキュアブート対応 ディスク暗号化（LUKS）のパスフレーズを Trusted Platform Module（TPM） 2.0 デバイスへ封入し、パスフレーズ入力無しで Kali Linux を起動 なぜセキュアブート対応するのか？は次回以降での解説とします。 ","date":"2020-10-26","objectID":"/bitlocker/:1:1","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"必要なもの TPM 2.0 を搭載した PC 本稿では ThinkCentre M90n-1 Nano を使いました Kali Linux のインストールメディア 本稿では kali-linux-2020.3-installer-netinst-amd64.iso を USB メモリへ入れて使いました ","date":"2020-10-26","objectID":"/bitlocker/:1:2","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"2 Kali Linux のインストール インストールの前に BIOS（UEFI）セットアップメニューを開き、以下のように設定します。 最近の Linux は Windows よりも簡単にインストールできるので手順は詳しく解説しません。 今回は以下の設定でインストールしましたが、パーティショニングの方法: ガイド - ディスク全体を使い、暗号化 LVM をセットアップする以外の部分はお好みで大丈夫です。 この際設定する LUKS 暗号化パスフレーズはセットアップ時に使用する他、TPM での起動ができなくなった場合にも使用するので安全に保管しておく必要があります。 言語: 日本語 ロケール: 日本 キーボード: 日本語 ホスト名: kali ドメイン名: (空白) ユーザー名: user パーティショニングの方法: ガイド - ディスク全体を使い、暗号化 LVM をセットアップする パーティショニング機構: すべてのファイルを 1 つのパーティションに（初心者ユーザには推奨） インストールするソフトウェア: 全て無し ","date":"2020-10-26","objectID":"/bitlocker/:2:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"パッケージのインストール Kali Linux のインストールが完了したら、設定した暗号化パスフレーズを入力しつつ Kali Linux を起動します。 ここからしばらくコマンドラインの作業になります。 一般ユーザーで実行可能な操作はほぼ無いため、以降の作業は全て root ユーザーで実行してください。 コピペで実行しやすいよう、# や $ は付けずに表記します。 ソースパッケージを有効化しつつ、必要なパッケージをインストールします。 grep '^deb ' /etc/apt/sources.list | sed 's/^deb /deb-src /g' | tee /etc/apt/sources.list.d/deb-src.list apt-get update apt-get install -y tpm2-tools tpm2-abrmd efibootmgr efitools binutils dosfstools uuid-runtime apt-get install -y build-essential flex bison bc rsync libelf-dev libssl-dev libncurses-dev ここで一度、TPM2 デバイスへアクセスできるか確認します。 tpm2_pcrread sha256 以下のように TPM2 の PCR レジスタが表示されたら成功です（0-7の値はXでマスクしてます）。 sha256: 0 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 1 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 2 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 3 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 4 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 5 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 6 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 7 : 0xXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX 8 : 0x0000000000000000000000000000000000000000000000000000000000000000 9 : 0x0000000000000000000000000000000000000000000000000000000000000000 10: 0x0000000000000000000000000000000000000000000000000000000000000000 11: 0x0000000000000000000000000000000000000000000000000000000000000000 12: 0x0000000000000000000000000000000000000000000000000000000000000000 13: 0x0000000000000000000000000000000000000000000000000000000000000000 14: 0x0000000000000000000000000000000000000000000000000000000000000000 15: 0x0000000000000000000000000000000000000000000000000000000000000000 16: 0x0000000000000000000000000000000000000000000000000000000000000000 17: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 18: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 19: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 20: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 21: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 22: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF 23: 0x0000000000000000000000000000000000000000000000000000000000000000 ","date":"2020-10-26","objectID":"/bitlocker/:3:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"パーティションの確認 lsblk コマンドで Kali Linux インストール後のパーティションの状態を確認します。 本稿で確認に使用した PC のストレージは NVMe だったため、以下のようになっています。 ハードディスクや SSD の場合は sda1 など別の結果が表示され、以降のコマンドで適宜読みかえが必要になるのでご注意ください。 lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT nvme0n1 259:0 0 477G 0 disk ├─nvme0n1p1 259:2 0 512M 0 part /boot/efi ├─nvme0n1p2 259:3 0 244M 0 part /boot └─nvme0n1p3 259:4 0 476.2G 0 part └─nvme0n1p3_crypt 254:0 0 476.2G 0 crypt ├─kali--vg-root 254:1 0 460.4G 0 lvm / └─kali--vg-swap_1 254:2 0 15.9G 0 lvm [SWAP] 以降は下記のパーティション構成を前提として記載します。 Kali Linux をインストールしたディスク: /dev/nvme0n1 EFIシステムパーティション（ESP）: /dev/nvme0n1p1 ブートパーティション: /dev/nvme0n1p2 LUKS 暗号化パーティション: /dev/nvme0n1p3 ","date":"2020-10-26","objectID":"/bitlocker/:4:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"Linuxカーネルのビルド Kali Linux をセキュアブート対応するには、Linux カーネルのビルドが必要になります。 ビルドはとても時間がかかります。 ここは環境による差分が無いので、コマンドをそのまま貼り付けて実行して大丈夫です。 以下のコマンドを実行してビルドが始まったら、次のステップへ進みます。 mkdir /root/linux-image chown -R _apt:root /root/linux-image cd /root/linux-image apt-get source linux-image-amd64 cd linux-* cd certs cat \u003c\u003cEOS \u003e x509.genkey [ req ] default_bits = 4096 distinguished_name = req_distinguished_name prompt = no string_mask = utf8only x509_extensions = myexts [ req_distinguished_name ] CN = Modules [ myexts ] basicConstraints=critical,CA:FALSE keyUsage=digitalSignature subjectKeyIdentifier=hash authorityKeyIdentifier=keyid EOS openssl req -new -nodes -utf8 -sha256 -days 36500 -batch -x509 -config x509.genkey -outform PEM -out kernel_key.pem -keyout kernel_key.pem cd .. cp /boot/config-$(uname -r) .config make olddefconfig sed -i.bak -e 's/.*CONFIG_MODULE_SIG_ALL\\W.*/CONFIG_MODULE_SIG_ALL=y/' \\ -e 's#.*CONFIG_MODULE_SIG_KEY\\W.*#CONFIG_MODULE_SIG_KEY=\"certs/kernel_key.pem\"#' \\ -e 's/.*CONFIG_SYSTEM_TRUSTED_KEYS\\W.*/CONFIG_SYSTEM_TRUSTED_KEYS=\"\"/' \\ -e 's/.*CONFIG_CRYPTO_SHA512\\W.*/CONFIG_CRYPTO_SHA512=y/' \\ -e 's/.*CONFIG_DEBUG_INFO\\W.*/CONFIG_DEBUG_INFO=n/' .config : | make -j $(nproc) bindeb-pkg ","date":"2020-10-26","objectID":"/bitlocker/:5:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"起動スクリプトの作成 Kali Linux 起動時に TPM2 から LUKS 暗号化パスフレーズを開封し、LUKS 暗号化されたパーティションを自動的にオープンするスクリプトを作成します。 スクリプトや必要なモジュールを initramfs へコピーするフックスクリプト、crypttab でスクリプトが実行されるよう準備しておきます。 ここは環境による差分が無いので、コマンドをそのまま貼り付けて実行して大丈夫です。 cat \u003c\u003cEOS \u003e /usr/local/bin/tpm2_unseal_lukskey #!/bin/sh tpm2_unseal -c 0x81000000 -p pcr:sha256:0,2,4,7 if [ \\$? -ne 0 ]; then /lib/cryptsetup/askpass \"Unlocking the disk fallback \\$CRYPTTAB_SOURCE (\\$CRYPTTAB_NAME). Enter passphrase: \" fi EOS cat \u003c\u003cEOS \u003e /etc/initramfs-tools/hooks/tpm2-initramfs-hook . /usr/share/initramfs-tools/hook-functions copy_exec /usr/lib/x86_64-linux-gnu/libtss2-tcti-device.so.0.0.0 copy_exec /usr/bin/tpm2_unseal copy_exec /usr/local/bin/tpm2_unseal_lukskey copy_modules_dir kernel/drivers/char/tpm EOS chmod +x /usr/local/bin/tpm2_unseal_lukskey chmod +x /etc/initramfs-tools/hooks/tpm2-initramfs-hook cp /etc/crypttab{,.bak} echo $(cut -d' ' -f 1,2 /etc/crypttab) unseal $(cut -d' ' -f 4 /etc/crypttab ),keyscript=/usr/local/bin/tpm2_unseal_lukskey \u003e /etc/crypttab ","date":"2020-10-26","objectID":"/bitlocker/:6:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"セキュアブート鍵の作成 セキュアブートに使用するを作成しておきます。 ここは環境による差分が無いので、コマンドをそのまま貼り付けて実行して大丈夫です。 mkdir /root/secureboot cd /root/secureboot uuidgen --random \u003e GUID.txt openssl req -newkey rsa:4096 -nodes -keyout PK.key -new -x509 -sha256 -days 3650 -subj \"/CN=Platform Key/\" -out PK.crt openssl x509 -outform DER -in PK.crt -out PK.cer cert-to-efi-sig-list -g \"$(\u003c GUID.txt)\" PK.crt PK.esl sign-efi-sig-list -g \"$(\u003c GUID.txt)\" -k PK.key -c PK.crt PK PK.esl PK.auth sign-efi-sig-list -g \"$(\u003c GUID.txt)\" -c PK.crt -k PK.key PK /dev/null rm_PK.auth openssl req -newkey rsa:4096 -nodes -keyout KEK.key -new -x509 -sha256 -days 3650 -subj \"/CN=Key Exchange Key/\" -out KEK.crt openssl x509 -outform DER -in KEK.crt -out KEK.cer cert-to-efi-sig-list -g \"$(\u003c GUID.txt)\" KEK.crt KEK.esl sign-efi-sig-list -g \"$(\u003c GUID.txt)\" -k PK.key -c PK.crt KEK KEK.esl KEK.auth openssl req -newkey rsa:4096 -nodes -keyout db.key -new -x509 -sha256 -days 3650 -subj \"/CN=Signature Database key/\" -out db.crt openssl x509 -outform DER -in db.crt -out db.cer cert-to-efi-sig-list -g \"$(\u003c GUID.txt)\" db.crt db.esl sign-efi-sig-list -g \"$(\u003c GUID.txt)\" -k KEK.key -c KEK.crt db db.esl db.auth ","date":"2020-10-26","objectID":"/bitlocker/:7:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"/boot パーティションの削除 本稿の手順で Linux を起動するようにすると、/boot 用のパーティションが不要になります（ディストリビューションによっては、最初からESPが /boot だったりしますよね）。 セキュリティ上の理由から、このパーティションは削除します。 ここは環境による差分が無いので、コマンドをそのまま貼り付けて実行して大丈夫です。 umount /boot/efi mkdir /root/boot_backup mv /boot/* /root/boot_backup umount /boot sed -i.bak -e '/\\/boot / s/^#*/#/' -e 's#/boot/efi#/efi#' /etc/fstab mkdir /efi mount -a ","date":"2020-10-26","objectID":"/bitlocker/:8:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"KeyToolの準備 セキュアブート鍵を UEFI ファームウェアへ登録するツールの KeyTool の使用準備をしておきます。 本稿の手順では、このパーティションを完全にお掃除する前に、一時的にセキュアブート鍵を置くストレージとして使用します。 手順としては USB メモリなどリムーバブルメディアを使ったほうがさらに安全性が高まります。 ここは環境による差分があるので注意してください。 mkfs.vfat -n SBKEY /dev/nvme0n1p2 mkdir /tmp/sbkey mount /dev/nvme0n1p2 /tmp/sbkey cp /root/secureboot/{PK.auth,KEK.esl,db.esl} /tmp/sbkey mkdir /efi/EFI/KeyTool cp /usr/lib/efitools/x86_64-linux-gnu/KeyTool.efi /efi/EFI/KeyTool efibootmgr --disk /dev/nvme0n1 --part 1 --create --label KeyTool --loader EFI/KeyTool/KeyTool.efi 最後のコマンドの実行結果例です。 PC 起動時、kali 以外に KeyTool も起動できるようになりました。 BootCurrent: 0000 Timeout: 1 seconds BootOrder: 0002,0000,000B,000C,0009,000A,0007,0006,0001 Boot0000* kali Boot0001* Windows Boot Manager Boot0006* Generic Usb Device Boot0007* CD/DVD Device Boot0009 UEFI: PXE IPV4 Network Card Boot000A UEFI: PXE IPV6 Network Card Boot000B* UEFI: PXE IPV4 Intel(R) Ethernet Connection (6) I219-LM Boot000C* UEFI: PXE IPV6 Intel(R) Ethernet Connection (6) I219-LM Boot0002* KeyTool ","date":"2020-10-26","objectID":"/bitlocker/:9:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"Unified Kernel Image の作成 手順の最初の方でやり始めた Linux カーネルのビルドは無事終わりましたでしょうか。 終わってないと次の手順へは進めないので、DARKMATTER の他の記事を読んで有意義な時間過ごすことをオススメします。 ビルドが終わっていたら、/root/linux-image に以下のような 3 つの deb パッケージファイルが作成されていると思います。 linux-headers-5.8.14_5.8.14-1_amd64.deb linux-libc-dev_5.8.14-1_amd64.deb linux-image-5.8.14_5.8.14-1_amd64.deb これらをインストールしつつ、Unified Kernel Image を作成・署名し、KeyTool と同じく EFI ブートエントリーへ登録します。 ここは環境による差分があるので注意してください。パーティションとカーネルリリース番号の部分です。 dpkg -i /root/linux-image/linux-*.deb echo \"$(grep -oP 'root=\\S+' /proc/cmdline) ro cryptdevice=$(cut -d\\ -f2 /etc/crypttab):$(cut -d\\ -f1 /etc/crypttab) quiet\" \u003e /root/secureboot/cmdline.txt mkdir /efi/EFI/Secure-Kali objcopy \\ --add-section .osrel=/usr/lib/os-release --change-section-vma .osrel=0x20000 \\ --add-section .cmdline=/root/secureboot/cmdline.txt --change-section-vma .cmdline=0x30000 \\ --add-section .linux=/boot/vmlinuz-5.8.14 --change-section-vma .linux=0x40000 \\ --add-section .initrd=/boot/initrd.img-5.8.14 --change-section-vma .initrd=0x3000000 \\ /usr/lib/systemd/boot/efi/linuxx64.efi.stub /efi/EFI/Secure-Kali/Secure-Kali.efi sbsign --key /root/secureboot/db.key --cert /root/secureboot/db.crt --output /efi/EFI/Secure-Kali/Secure-Kali.efi /efi/EFI/Secure-Kali/Secure-Kali.efi efibootmgr --disk /dev/nvme0n1 --part 1 --create --label Secure-Kali --loader EFI/Secure-Kali/Secure-Kali.efi 最後のコマンドの実行結果例です。 PC 起動時、作成した Unified Kernel Image も起動できるようになりました（一番下）。 BootCurrent: 0000 Timeout: 1 seconds BootOrder: 0003,0002,0000,000B,000C,0009,000A,0007,0006,0001 Boot0000* kali Boot0001* Windows Boot Manager Boot0002* KeyTool Boot0006* Generic Usb Device Boot0007* CD/DVD Device Boot0009 UEFI: PXE IPV4 Network Card Boot000A UEFI: PXE IPV6 Network Card Boot000B* UEFI: PXE IPV4 Intel(R) Ethernet Connection (6) I219-LM Boot000C* UEFI: PXE IPV6 Intel(R) Ethernet Connection (6) I219-LM Boot0003* Secure-Kali ","date":"2020-10-26","objectID":"/bitlocker/:10:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"セキュアブートのモードをセットアップモードへ さて、ここまで来たら全体の作業の 2/3 程度は完了です。 ここからは UEFI（BIOS）セットアップメニューと KeyTool の操作になります。 UEFI（BIOS）セットアップメニューの操作は PC 環境依存となりますが、参考までに画像を使って説明します。 以下の Kali Linux を終了し、UEFI（BIOS）セットアップメニューを開きます。 systemctl reboot --firmware-setup セキュアブートを有効化します。 マイクロソフトのセキュアブート鍵を削除し、セットアップモードに入ります。 後で Windows を入れ直したい方は、ファクトリーキーのリストア（図中だと Restore Factory Keys）が可能なことを確認してから進んでください。 削除したセキュアブート鍵を戻せなくなる可能性があります。 また、セットアップモードへ入る操作が無い UEFI ファームウェアの場合は、手動でセキュアブート鍵を削除する必要があります。 セットアップモードになったところです。 設定を保存して再起動します。 ","date":"2020-10-26","objectID":"/bitlocker/:11:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"セキュアブート鍵の登録 KeyTool を使ってセキュアブート鍵を UEFI ファームウェアへ登録します。 起動デバイスの選択画面（PC 起動時に F12 キーなど）を表示し、 KeyTool を選択して起動します。 ","date":"2020-10-26","objectID":"/bitlocker/:12:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"セキュアブートのモード確認 UEFI（BIOS）セットアップメニューを開き、モードがSetup ModeからUser Modeへと切り替わったことを確認します。 ","date":"2020-10-26","objectID":"/bitlocker/:13:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"カスタムカーネルの起動 PC を再起動すると、カスタムカーネル（署名した Unified Kernel Image）の起動が始まります。 以下のようなエラーメッセージとともにパスフレーズの入力を求められるので、設定した暗号化パスフレーズを入力してカスタムカーネルを起動します。 以下のようなエラーが表示された場合、セキュアブート鍵の作成、カスタムカーネルの署名、セキュアブート鍵の登録のいずれかがうまくいっていないと考えられます。 原理的な理解が無いと、どこからやり直せばいいのか判断が難しいです。 一旦セキュアブートを無効化して起動できるようであれば試行錯誤してみて、駄目そうなら最初からやり直してください。。 Secure Boot Violation Invalid signature detected. Check Secure Boot Policy Setup. 上記エラーは表示されないがパスフレーズの入力を求めるところまで行かないという場合、起動時のログを多めに出さないと何が失敗してるのか判断が難しいです。 一旦セキュアブートを無効化して起動できるようであれば、cmdline（/root/secureboot/cmdline.txt）へ loglevel=9 などと書き、Unified Kernel Image の作成で実施した objcopy と sbsign をやり直し、セキュアブートを有効化して再起動します。 多くの場合、カーネルモジュールの署名や検証の問題が起きていると思われます。 Linux カーネルのビルドあたりからやり直すと問題が解決する可能性がありますが、最初からやり直したほうがスッキリするかもしれません。。 ","date":"2020-10-26","objectID":"/bitlocker/:14:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"TPM2 へ LUKS パスフレーズを封入 無事ここまで到達されたみなさまは、大変おめでとうございます。 いよいよ本題の Kali Linux で BitLocker ぽいことができます。 設定したものとは異なるランダムな LUKS パスフレーズを追加後、TPM2 の不揮発性メモリ（NVRAM）へ同じパスフレーズを封入します。 再起動後、ディスク暗号化のパスフレーズ入力を求められることなく Kali Linux が起動したら成功です。 ここは環境による差分があるので注意してください。 umask 0077 head -c 128 /dev/urandom \u003e /root/luks_passphrase.bin cryptsetup luksAddKey /dev/nvme0n1p3 /root/luks_passphrase.bin mkdir /tmp/tpm2 cd /tmp/tpm2 tpm2_evictcontrol --hierarchy o --object-context 0x81000000 tpm2_pcrread --output /root/pcrs.bin sha256:0,2,4,7 tpm2_createpolicy --policy-pcr --policy pcr.policy --pcr-list sha256:0,2,4,7 --pcr /root/pcrs.bin tpm2_createprimary --hierarchy=o --key-algorithm=ecc --key-context=prim.ctx tpm2_create --hash-algorithm sha256 --public seal.pub --private seal.priv --sealing-input /root/luks_passphrase.bin --parent-context prim.ctx --policy pcr.policy tpm2_load --parent-context prim.ctx --public seal.pub --private seal.priv --key-context seal.ctx tpm2_evictcontrol --hierarchy o --object-context seal.ctx 0x81000000 tpm2_flushcontext --saved-session systemctl reboot ","date":"2020-10-26","objectID":"/bitlocker/:15:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"お掃除 不要なファイルや EFI エントリーを削除、/boot だったパーティションを削除します。 システムをセキュアに保つために重要な作業です。 ここは環境による差分があるので注意してください。 不要な EFI バイナリ削除 rm -rf /efi/EFI/KeyTool rm -rf /efi/EFI/kali 不要な EFI エントリーの番号を取得 efibootmgr | egrep 'kali|KeyTool' 本稿の環境では 0000 および 0002 でした。 Boot0000* kali Boot0002* KeyTool これらを削除。 efibootmgr --delete-bootnum --bootnum 0000 efibootmgr --delete-bootnum --bootnum 0002 /boot だったパーティションへランダムなデータを上書きして削除 shred /dev/nvme0n1p2 ","date":"2020-10-26","objectID":"/bitlocker/:16:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"セキュアブート状態の確認 # od --address-radix=n --format=u1 /sys/firmware/efi/efivars/SecureBoot-* 6 0 0 0 1 \u003c= 最後の数字が 1 だったらセキュアブート # bootctl status systemd-boot not installed in ESP. No default/fallback boot loader installed in ESP. System: Firmware: UEFI 2.70 (American Megatrends 5.13) Secure Boot: enabled \u003c= セキュアブートが有効 Setup Mode: user \u003c= User Modeであることが確認できる Current Boot Loader: Product: n/a Features: ✗ Boot counting ✗ Menu timeout control ✗ One-shot menu timeout control ✗ Default entry control ✗ One-shot entry control ✗ Support for XBOOTLDR partition ✗ Support for passing random seed to OS ✓ Boot loader sets ESP partition information Stub: systemd-stub 245.6-1 ESP: /dev/disk/by-partuuid/93a0e4c0-9adb-42c7-81fc-5f4fbd5b63d0 File: └─EFI/Secure-Kali/Secure-Kali.efi Random Seed: Passed to OS: no System Token: not set Exists: no Available Boot Loaders on ESP: ESP: /efi (/dev/disk/by-partuuid/93a0e4c0-9adb-42c7-81fc-5f4fbd5b63d0) Boot Loaders Listed in EFI Variables: Title: Secure-Kali ID: 0x0003 Status: active, boot-order Partition: /dev/disk/by-partuuid/93a0e4c0-9adb-42c7-81fc-5f4fbd5b63d0 File: └─EFI/Secure-Kali/Secure-Kali.efi Boot Loader Entries: $BOOT: /efi (/dev/disk/by-partuuid/93a0e4c0-9adb-42c7-81fc-5f4fbd5b63d0) 0 entries, no entry could be determined as default. ","date":"2020-10-26","objectID":"/bitlocker/:17:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":[],"content":"おわりに おつかれさまでした。 最後までうまくいった方はおめでとうございます。 うまくいかなかった方は次回以降の解説でヒントがつかめると幸いです。 これよりも難しいことをボタンぽちぽちでよろしくやってくれる BitLocker は本当にすごいですね。 ","date":"2020-10-26","objectID":"/bitlocker/:18:0","tags":["PKI"],"title":"Kali LinuxでBitLocker ~やってみる編 ~","uri":"/bitlocker/"},{"categories":null,"content":" DARK MATTERは株式会社サイバーディフェンス研究所のエンジニアによるテックブログです。 日頃からWebアプリケーション、ネットワーク、組み込み機器、制御システムなどを対象とした脆弱性診断・ペネトレーションテストに従事しているエンジニアならではの情報を発信していきます。 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About DARK MATTER","uri":"/about/"},{"categories":null,"content":"サイバーディフェンス研究所について 会社概要 沿革 ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About DARK MATTER","uri":"/about/"},{"categories":null,"content":"サイバーディフェンス研究所のセキュリティ診断 Webアプリケーション脆弱性診断 スマートフォンアプリ脆弱性診断 ネットワークペネトレーションテスト 組み込み機器・IoTセキュリティ診断 制御システムペネトレーションテスト ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About DARK MATTER","uri":"/about/"},{"categories":null,"content":"サイバーディフェンス研究所のトレーニング サイバー演習 ハッキング セキュリティ診断 セキュアコーディング フォレンジック・IR マルウェア・プログラム解析 Exploit Writing ","date":"2019-08-02","objectID":"/about/:0:3","tags":null,"title":"About DARK MATTER","uri":"/about/"},{"categories":null,"content":"自学自習サービス「INFINITY CHAMBER」 ","date":"2019-08-02","objectID":"/about/:0:4","tags":null,"title":"About DARK MATTER","uri":"/about/"},{"categories":null,"content":"採用情報 ","date":"2019-08-02","objectID":"/about/:0:5","tags":null,"title":"About DARK MATTER","uri":"/about/"}]